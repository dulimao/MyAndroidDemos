

------------内存泄漏-------------
	当一个对象不再使用了，本该被回收时，
而有另外一个正在使用的对象持有他的引用，
从而导致该对象不能被回收，这块内存永远
无法重新利用。
	对象不再有任何引用的时候才会被回收。
内存分配的策略：
1.静态
	静态存储区：内存在程序编译的时
候就分配好了，这块内存在程序整个运行期间
一直存在。它主要存放静态数据、全局的static
数据和一些常量。

2.栈式
	在执行方法时，方法的一些局部变量可以放在
栈上面创建，方法执行结束后，这些存储单元就会
被自动释放掉。栈内存包括分配的运算是速度很快，
因为内置在处理器（寄存器）的里面，但是容量有限。

3.堆式
	动态内存分配，可以用new来申请分配一块内存，
在C/C++需要自己负责释放，java里面直接依赖GC。

区别：栈式一块连续的内存区域，大小是由操作系统
确定的。堆是不连续的内存区域，频繁的new/remove
会造成大量的内存碎片，这样会慢慢导致效率低下。

public class Main{
	int a = 1;
	Student s = new Student();//堆
	public void XXX(){
		int b = 1;//栈里面
		//s2:栈，new Student():堆
		Student s2 = new Student();
	}

}

	成员变量全部全部存储在堆中（包括基本数据类型，
引用和引用的对象实体），因为他们属于类，而类
是被new出来的。
	局部变量的基本数据类型和引用存储在栈当中，引用
的对象实体在堆中。

四大引用：
StrongReference强引用：
	回收时机：从不回收 使用：对象的一般保存  
	生命周期：JVM停止的时候才会终止
SoftReference，软引用
	回收时机：当内存不足的时候；
	使用：SoftReference<String>结合ReferenceQueue构造有效期短；
	生命周期：内存不足时终止
WeakReference，弱引用
	回收时机：在垃圾回收的时候；
	使用：同软引用； 
	生命周期：GC后终止
PhatomReference 虚引用
	回收时机：在垃圾回收的时候；
	使用：合ReferenceQueue来跟踪对象呗垃圾回收期回收的活动；


	为了防止内存溢出，处理一些占用内存较大，并且生命周期
长的对象的时候，可以尽量使用软引用和弱引用。


1.凭借工具结合自己的经验查找内存泄漏。
2.养成良好的编程习惯。
3.查看内存抖动情况
4.对照内存快照，查看被引用对象

排查工具（工具只是提供线索）：
Android Profile，
MAT(针对java层)

内存泄漏案例：
1、单例持有Activity引用，多次旋转屏幕，造成Activity内存泄漏
	结论：（Android Profiler）旋转3次：会在内存里面开辟三个
	MainActivity
实际上3次以上都只会有2个MainActivity。
MainActivity。当GC回收的时候会将除了第0个
和最后这一个留着其他的都会被回收。









-----------------------UI优化--------------------------
渲染机制：
	60HZ=60fps是屏幕刷新的理想频率，16ms系统会发出
信号(VSYNC:垂直刷新)，渲染UI，就会正常绘制，如果
超过16ms没绘制完成就会造成掉帧卡顿。

CSYNC(垂直刷新/绘制):有两个概念：
	1：Refresh Rate(硬件):屏幕在一秒内刷新屏幕的次数，
	由硬件的参数决定，比如：60HZ.
	2:Frame Rate:GPU在一秒内绘制的整数，60fps
GPU:帮助我们将UI组件等计算成纹理Texture和三维图形，
	同时会使用OpenGL将纹理和Polygons缓存在GPU内存里面。
	硬件加速。

 卡顿是如何造成的
	 1.外部引起的：比如主线程中执行了耗时操作
	 2.View本身的卡顿 ：如自定义View

	 内存需要注意的问题：要防止内存抖动，因为
	 频繁GC会阻断主线程，造成卡顿。

 优化：
	 1.渲染性能的优化。
	 2.防止过度绘制。
	 3.适当情况下让GPU去绘制，减少CPU负担
	 4.要防止内存抖动（首先通过Android Moniter）
	 5.使用TraeView来确定详细的问题
	 6.CPU消耗严重

TraceView:
	柱状图：第一个表示内存分配开始，第二个表示当前分配
	的内存使用结束，中间区域表示方法的执行时间，
	可以看到上面的方法名。颜色一样表示一个方法被反复调用

	左边线程面板，右边时间轴面板，下边是时间轴详细信息

几个重要参数：
	Incl Cpu Time:CPU占用时间或占比，包括调用其他方法
	Excl Cpu TIme:不包含调用其他方法，仅自身的消耗时间或占比
	Incl Real Time:真实CPU时间，不包括CPU以外的时间或占比，一般小于 Incl Cpu Time.
	Call+RecurCall:调用和递归重复调用的次数
	Cpu Time/Call:平均消耗CPU时间