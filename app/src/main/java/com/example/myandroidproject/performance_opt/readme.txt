性能优化

------------内存泄漏-------------
	当一个对象不再使用了，本该被回收时，
而有另外一个正在使用的对象持有他的引用，
从而导致该对象不能被回收，这块内存永远
无法重新利用。
	对象不再有任何引用的时候才会被回收。
内存分配的策略：
1.静态
	静态存储区：内存在程序编译的时
候就分配好了，这块内存在程序整个运行期间
一直存在。它主要存放静态数据、全局的static
数据和一些常量。

2.栈式
	在执行方法时，方法的一些局部变量可以放在
栈上面创建，方法执行结束后，这些存储单元就会
被自动释放掉。栈内存包括分配的运算是速度很快，
因为内置在处理器（寄存器）的里面，但是容量有限。

3.堆式
	动态内存分配，可以用new来申请分配一块内存，
在C/C++需要自己负责释放，java里面直接依赖GC。

区别：栈式一块连续的内存区域，大小是由操作系统
确定的。堆是不连续的内存区域，频繁的new/remove
会造成大量的内存碎片，这样会慢慢导致效率低下。

public class Main{
	int a = 1;
	Student s = new Student();//堆
	public void XXX(){
		int b = 1;//栈里面
		//s2:栈，new Student():堆
		Student s2 = new Student();
	}

}

	成员变量全部全部存储在堆中（包括基本数据类型，
引用和引用的对象实体），因为他们属于类，而类
是被new出来的。
	局部变量的基本数据类型和引用存储在栈当中，引用
的对象实体在堆中。

四大引用：
StrongReference强引用：
	回收时机：从不回收 使用：对象的一般保存
	生命周期：JVM停止的时候才会终止
SoftReference，软引用
	回收时机：当内存不足的时候；
	使用：SoftReference<String>结合ReferenceQueue构造有效期短；
	生命周期：内存不足时终止
WeakReference，弱引用
	回收时机：在垃圾回收的时候；
	使用：同软引用；
	生命周期：GC后终止
PhatomReference 虚引用
	回收时机：在垃圾回收的时候；
	使用：合ReferenceQueue来跟踪对象呗垃圾回收期回收的活动；


	为了防止内存溢出，处理一些占用内存较大，并且生命周期
长的对象的时候，可以尽量使用软引用和弱引用。